<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <title>Flappy Shape - Full Features</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      background:#111;
      display:block;
      height:100vh;
      width:100vw;
      margin:0;
      overflow:hidden;
      font-family:Arial,Helvetica,sans-serif;
      color:#fff;
    }
    #gameContainer{position:fixed; inset:0}
    canvas{
      width:100vw;
      height:100vh;
      background:#4d9fff; /* will be overridden by drawn image */
      display:block;
    }
    #overlay{
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      transition:opacity 200ms ease;
      pointer-events:none;
    }
    #info{
      position:absolute;
      top:8px;
      left:8px;
      right:8px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:14px;
      gap:12px;
    }
    .shape-preview{
      width:30px;
      height:30px;
      background-size:cover;
      background-position:center;
      border-radius:6px;
      border:2px solid rgba(0,0,0,0.4);
    }
    .mobile-controls{
      position:absolute;
      bottom:14px;
      left:50%;
      transform:translateX(-50%);
      display:flex;
      gap:8px;
      pointer-events:auto;
    }
    .btn{
      background:rgba(255,255,255,0.12);
      border:2px solid rgba(255,255,255,0.18);
      padding:8px 12px;
      border-radius:10px;
      color:#fff;
      font-weight:600;
      user-select:none;
      box-shadow:0 6px 18px rgba(0,0,0,0.35);
    }
    .btn:active{transform:translateY(2px)}
    .difficulty-info{font-size:12px;opacity:0.9}
    .hint{position:absolute;bottom:8px;left:50%;transform:translateX(-50%);font-size:12px;opacity:0.8}
    @media (max-width:420px){ .shape-preview{width:34px;height:34px} .btn{padding:10px 14px} }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="game"></canvas>

    <div id="overlay">
      <h1 id="titleText">Flappy Shape</h1>
      <p id="subText">TAP di mana saja untuk mulai — 1/2/3 ganti gambar</p>
    </div>

    <div id="info">
      <div style="display:flex;flex-direction:column;align-items:flex-start">
        <div>Skor: <span id="scoreText">0</span></div>
        <div class="difficulty-info">Gap: <span id="gapText">-</span> px · Speed: <span id="speedText">-</span></div>
      </div>
      <div style="display:flex;align-items:center;gap:8px">
        <div>Bentuk:</div>
        <div id="shapePreview" class="shape-preview" title="Preview"></div>
      </div>
    </div>

    <div class="mobile-controls" id="mobileControls" style="display:none">
      <div class="btn" id="btnFlap">FLAP</div>
      <div class="btn" id="btn1">1</div>
      <div class="btn" id="btn2">2</div>
      <div class="btn" id="btn3">3</div>
    </div>

  </div>

<script>
/* ========= CONFIG =========
   - support foto lokal: sesuaikan path jika perlu
   - dynamic difficulty values di bawah dapat di-tweak
*/
const localImages = {
  circle: 'local/1.jpg',
  square: 'local/2.jpg',
  triangle: 'local/3.jpg'
};

const difficultyConfig = {
  initialGap: 300,           // gap awal (px)
  minGap: 200,               // gap minimal (px)
  shrinkPerSecond: 3.0,      // gap mengecil per detik (lebih pelan)
  shrinkPerScore: 1.2,       // tambahan pengecilan per skor (lebih pelan)
  basePipeSpeed: 1.6,        // kecepatan pipa awal (lebih pelan)
  maxPipeSpeed: 4.0,         // kecepatan maksimal (diturunkan)
  speedIncreasePerScore: 0.08, // kecepatan naik per skor (lebih pelan)
  basePipeSpacing: 360,      // jarak awal antar pipa (lebih longgar)
  minPipeSpacing: 260,       // jarak minimal antar pipa (lebih longgar)
  spacingDecreasePerScore: 1.0 // pengurangan spacing per skor (lebih pelan)
};

/* fallback svg data-url jika foto tidak ada */
function svgToDataURL(svg){ return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg); }
const fallback = {
  circle: svgToDataURL("<svg xmlns='http://www.w3.org/2000/svg' width='128' height='128'><circle cx='64' cy='64' r='44' fill='#ffe066' stroke='#000' stroke-width='4'/></svg>"),
  square: svgToDataURL("<svg xmlns='http://www.w3.org/2000/svg' width='128' height='128'><rect x='28' y='28' width='72' height='72' rx='8' fill='#ff6b6b' stroke='#000' stroke-width='4'/></svg>"),
  triangle: svgToDataURL("<svg xmlns='http://www.w3.org/2000/svg' width='128' height='128'><path d='M64 24 L28 100 L100 100 Z' fill='#4ecdc4' stroke='#000' stroke-width='4'/></svg>")
};

/* load sprites (2 frame placeholders each; photos duplicated) */
const sprites = {
  circle: [ new Image(), new Image() ],
  square: [ new Image(), new Image() ],
  triangle: [ new Image(), new Image() ]
};
/* attempt load local images, fallback to svg if fail */
Object.keys(localImages).forEach(shape=>{
  const path = localImages[shape];
  const img = new Image();
  img.onload = ()=>{ sprites[shape][0] = img; sprites[shape][1] = img; if(player.shape===shape) updatePreview(); };
  img.onerror = ()=>{ sprites[shape][0].src = fallback[shape]; sprites[shape][1].src = fallback[shape]; if(player.shape===shape) updatePreview(); };
  img.src = path;
});

/* ======== GAME CORE ======== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const overlay = document.getElementById('overlay');
const scoreText = document.getElementById('scoreText');
const gapText = document.getElementById('gapText');
const speedText = document.getElementById('speedText');
const shapePreview = document.getElementById('shapePreview');

let W = window.innerWidth, H = window.innerHeight;
canvas.width = W; canvas.height = H;
const shapes = ['circle','square','triangle'];

const player = {
  x: 100,
  y: H/2,
  radius: 36,
  vy: 0,
  gravity: 0.45,
  flapStrength: -9.2,
  shape: 'circle'
};

let score = 0;
let pipes = [];
const pipeWidth = 90;

let gameRunning = false;
let gameOver = false;
let animTimer = 0;
let lastAnimTime = performance.now();
let gameStartTimestamp = null;

/* preview update */
function updatePreview(){
  const img = sprites[player.shape][0];
  if(img && img.src) {
    shapePreview.style.backgroundImage = `url("${img.src}")`;
    shapePreview.style.backgroundSize = 'cover';
    shapePreview.style.backgroundPosition = 'center';
  }
}
/* background image path (change as needed) */
const bgImagePath = 'local/bg.jpg';
let bgImage = new Image();
let bgImageLoaded = false;
bgImage.onload = ()=>{ bgImageLoaded = true; };
bgImage.onerror = ()=>{ bgImageLoaded = false; };
bgImage.src = bgImagePath;


/* dynamic difficulty calculations */
function computeCurrentGap(){
  if(!gameStartTimestamp) return difficultyConfig.initialGap;
  const elapsed = (performance.now() - gameStartTimestamp)/1000;
  let gap = difficultyConfig.initialGap - difficultyConfig.shrinkPerSecond*elapsed - difficultyConfig.shrinkPerScore*score;
  if(gap < difficultyConfig.minGap) gap = difficultyConfig.minGap;
  return Math.round(gap);
}
function computeCurrentPipeSpeed(){
  let speed = difficultyConfig.basePipeSpeed + score * difficultyConfig.speedIncreasePerScore;
  if(speed > difficultyConfig.maxPipeSpeed) speed = difficultyConfig.maxPipeSpeed;
  return parseFloat(speed.toFixed(3));
}
function computeCurrentSpacing(){
  let spacing = difficultyConfig.basePipeSpacing - score * difficultyConfig.spacingDecreasePerScore;
  if(spacing < difficultyConfig.minPipeSpacing) spacing = difficultyConfig.minPipeSpacing;
  return Math.round(spacing);
}
function updateDifficultyUI(){
  gapText.textContent = computeCurrentGap();
  speedText.textContent = computeCurrentPipeSpeed();
}

/* spawn pipe using current gap */
function spawnPipe(){
  const gap = computeCurrentGap();
  const margin = 60;
  const gapY = margin + Math.random()*(H - 2*margin - gap);
  // add vertical oscillation for moving obstacle
  const oscAmp = Math.min(70, Math.max(24, Math.floor(H * 0.06))); // amplitude a bit smaller
  const oscSpeed = 0.0009 + Math.random()*0.0007; // slower oscillation
  const oscPhase = Math.random() * Math.PI * 2;
  pipes.push({ x: W + 40, gapY, gapHeight: gap, passed: false, oscAmp, oscSpeed, oscPhase });
}

/* start / flap */
function flap(){
  if(gameOver){
    location.reload();
    return;
  }
  if(!gameRunning){
    gameRunning = true;
    overlay.style.display = 'none';
    gameStartTimestamp = performance.now();
  }
  player.vy = player.flapStrength;
}

/* random shape (avoid same) */
function randomShape(){
  let s;
  do s = shapes[Math.floor(Math.random()*shapes.length)];
  while(s === player.shape);
  return s;
}

/* game over */
function triggerGameOver(){
  if(gameOver) return;
  gameOver = true;
  gameRunning = false;
  overlay.style.display = 'flex';
  overlay.style.opacity = 1;
  document.getElementById('titleText').textContent = 'Game Over';
  document.getElementById('subText').innerHTML = `Skor kamu: ${score}<br>TAP di mana saja untuk restart`;
}

function getGroundHeight(){ return Math.max(60, Math.floor(H*0.06)); }

/* main update loop */
function update(now){
  const dt = now - lastAnimTime;
  lastAnimTime = now;
  animTimer += dt;

  if(gameRunning && !gameOver){
    player.vy += player.gravity;
    player.y += player.vy;

    // bounds
    if(player.y - player.radius < 0 || player.y + player.radius > H - getGroundHeight()){
      triggerGameOver();
    }

    // spawn based on dynamic spacing
    const currentSpacing = computeCurrentSpacing();
    if(pipes.length === 0 || (W - pipes[pipes.length-1].x) >= currentSpacing){
      spawnPipe();
    }

    // move pipes with dynamic speed
    const currentSpeed = computeCurrentPipeSpeed();
    for(let i = pipes.length-1; i>=0; i--){
      const p = pipes[i];
      p.x -= currentSpeed;

      // apply vertical oscillation to the gap center
      const t = now; // ms from rAF time
      const baseCenter = p.gapY + p.gapHeight/2;
      const oscOffset = Math.sin(p.oscPhase + t * p.oscSpeed) * p.oscAmp;
      const newCenter = baseCenter + oscOffset;
      // clamp so pipes stay within bounds
      const minCenter = p.gapHeight/2 + 20;
      const maxCenter = H - getGroundHeight() - p.gapHeight/2 - 20;
      const clampedCenter = Math.min(Math.max(newCenter, minCenter), maxCenter);
      p.gapY = clampedCenter - p.gapHeight/2;

      const withinX = (player.x + player.radius > p.x) && (player.x - player.radius < p.x + pipeWidth);
      if(withinX){
        const inGap = (player.y - player.radius >= p.gapY) && (player.y + player.radius <= p.gapY + p.gapHeight);
        if(!inGap){
          triggerGameOver();
        } else {
          if(!p.passed){
            p.passed = true;
            score++;
            scoreText.textContent = score;

            // auto-random shape after passing
            player.shape = randomShape();
            updatePreview();
          }
        }
      }

      if(p.x + pipeWidth < -50) pipes.splice(i,1);
    }

    updateDifficultyUI();
  }

  draw();
  requestAnimationFrame(update);
}

/* draw helpers */
function drawBackground(){
  const groundHeight = Math.max(60, Math.floor(H*0.06));
  // draw sky/background image (cover behavior)
  if(bgImageLoaded){
    // compute cover scaling
    const imgW = bgImage.naturalWidth || bgImage.width;
    const imgH = bgImage.naturalHeight || bgImage.height;
    const scale = Math.max(W / imgW, H / imgH);
    const drawW = imgW * scale;
    const drawH = imgH * scale;
    const dx = (W - drawW) / 2;
    const dy = (H - drawH) / 2;
    ctx.drawImage(bgImage, dx, dy, drawW, drawH);
  } else {
    // fallback gradient sky
    const grad = ctx.createLinearGradient(0,0,0,H);
    grad.addColorStop(0,'#4d9fff');
    grad.addColorStop(1,'#88ddff');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,W,H);
  }
  ctx.fillStyle = "#27ae60";
  ctx.fillRect(0, H-groundHeight, W, groundHeight);
  ctx.fillStyle = "#2ecc71";
  ctx.fillRect(0, H-groundHeight+5, W, groundHeight-5);

  ctx.fillStyle = "rgba(255,255,255,0.85)";
  // optional clouds removed to let background image show clearly
}

function drawPlayer(){
  ctx.save();
  ctx.translate(player.x, player.y);

  const frameIndex = Math.floor((animTimer/140) % 2);
  const img = sprites[player.shape][frameIndex];
  const size = player.radius * 2;

  if(img && img.complete && img.naturalWidth !== 0){
    ctx.drawImage(img, -size/2, -size/2, size, size);
  } else {
    // fallback simple shape
    ctx.fillStyle = player.shape === 'circle' ? '#ffe066' : player.shape === 'square' ? '#ff6b6b' : '#4ecdc4';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 3;
    if(player.shape === 'circle'){
      ctx.beginPath(); ctx.arc(0,0,player.radius,0,Math.PI*2); ctx.fill(); ctx.stroke();
    } else if(player.shape === 'square'){
      const s = player.radius*1.6; ctx.beginPath(); ctx.rect(-s/2,-s/2,s,s); ctx.fill(); ctx.stroke();
    } else {
      const s = player.radius*2; ctx.beginPath(); ctx.moveTo(-s/2,s/2); ctx.lineTo(0,-s/2); ctx.lineTo(s/2,s/2); ctx.closePath(); ctx.fill(); ctx.stroke();
    }
  }

  ctx.restore();
}

function drawPipe(p){
  ctx.fillStyle = "#2ecc71";
  ctx.fillRect(p.x, 0, pipeWidth, p.gapY);
  ctx.fillRect(p.x, p.gapY + p.gapHeight, pipeWidth, H - (p.gapY + p.gapHeight));
  ctx.save();
  ctx.translate(p.x + pipeWidth/2, p.gapY + p.gapHeight/2);
  ctx.fillStyle = "rgba(255,255,255,0.35)";
  ctx.fillRect(-pipeWidth/2, -p.gapHeight/2, pipeWidth, p.gapHeight);
  ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,W,H);
  drawBackground();
  pipes.forEach(drawPipe);
  drawPlayer();
}

/* inputs */
window.addEventListener('keydown', (e)=>{
  if(e.code === 'Space'){ e.preventDefault(); flap(); }
  else if(e.code === 'Digit1'){ player.shape = 'circle'; updatePreview(); }
  else if(e.code === 'Digit2'){ player.shape = 'square'; updatePreview(); }
  else if(e.code === 'Digit3'){ player.shape = 'triangle'; updatePreview(); }
});
// Tap/click anywhere to start or restart
document.addEventListener('mousedown', flap);
document.addEventListener('touchstart', (e)=>{ e.preventDefault(); flap(); }, {passive:false});

/* mobile buttons */
const mobileControls = document.getElementById('mobileControls');
const btnFlap = document.getElementById('btnFlap');
const btn1 = document.getElementById('btn1');
const btn2 = document.getElementById('btn2');
const btn3 = document.getElementById('btn3');

btnFlap.addEventListener('click', flap);
btn1.addEventListener('click', ()=>{ player.shape='circle'; updatePreview(); });
btn2.addEventListener('click', ()=>{ player.shape='square'; updatePreview(); });
btn3.addEventListener('click', ()=>{ player.shape='triangle'; updatePreview(); });

btnFlap.addEventListener('touchstart', (e)=>{ e.preventDefault(); flap(); }, {passive:false});
btn1.addEventListener('touchstart', (e)=>{ e.preventDefault(); player.shape='circle'; updatePreview(); }, {passive:false});
btn2.addEventListener('touchstart', (e)=>{ e.preventDefault(); player.shape='square'; updatePreview(); }, {passive:false});
btn3.addEventListener('touchstart', (e)=>{ e.preventDefault(); player.shape='triangle'; updatePreview(); }, {passive:false});

/* adapt UI */
function adaptUI(){ const isMobile = window.innerWidth <= 480 || ('ontouchstart' in window && window.innerWidth < 768); mobileControls.style.display = isMobile ? 'flex' : 'none'; }
function resizeCanvas(){
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W; canvas.height = H;
  // keep player within bounds when resizing
  player.y = Math.min(Math.max(player.radius+5, player.y), H - player.radius - 5);
}
window.addEventListener('resize', ()=>{ resizeCanvas(); adaptUI(); });
resizeCanvas();

/* start */
updatePreview();
requestAnimationFrame(update);
</script>
</body>
</html>
